// Type definitions for prettier 2.7
// Project: https://prettier.io
//          https://github.com/prettier/prettier
// Definitions by: Ika <https://github.com/ikatyang>
//                 Ifiok Jr. <https://github.com/ifiokjr>
//                 Florian Imdahl <https://github.com/ffflorian>
//                 Sosuke Suzuki <https://github.com/sosukesuzuki>
//                 Christopher Quadflieg <https://github.com/Shinigami92>
//                 Georgii Dolzhykov <https://github.com/thorn0>
//                 JounQin <https://github.com/JounQin>
//                 Chuah Chee Shian <https://github.com/shian15810>
//                 Marc Gibbons <https://github.com/marcgibbons>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
// Minimum TypeScript Version: 4.2

// Adding export {} here to shut off automatic exporting from index.d.ts. There
// are quite a few utility types here that don't need to be shipped with the
// exported module.
export {};

// This utility is here to handle the case where you have an explicit union
// between string literals and the generic string type. It would normally
// resolve out to just the string type, but this generic LiteralUnion maintains
// the intellisense of the original union.
//
// It comes from this issue: microsoft/TypeScript#29729:
//   https://github.com/microsoft/TypeScript/issues/29729#issuecomment-700527227
export type LiteralUnion<T extends U, U = string> = T | (Pick<U, never> & { _?: never | undefined });

export type AST = any;
export type Doc = doc.builders.Doc;

// The type of elements that make up the given array T.
type ArrayElement<T> = T extends Array<infer E> ? E : never;

// A union of the properties of the given object that are arrays.
type ArrayProperties<T> = { [K in keyof T]: NonNullable<T[K]> extends any[] ? K : never }[keyof T];

// A union of the properties of the given array T that can be used to index it.
// If the array is a tuple, then that's going to be the explicit indices of the
// array, otherwise it's going to just be number.
type IndexProperties<T extends { length: number }> = IsTuple<T> extends true
    ? Exclude<Partial<T>['length'], T['length']>
    : number;

// Effectively performing T[P], except that it's telling TypeScript that it's
// safe to do this for tuples, arrays, or objects.
type IndexValue<T, P> = T extends any[] ? (P extends number ? T[P] : never) : P extends keyof T ? T[P] : never;

// Determines if an object T is an array like string[] (in which case this
// evaluates to false) or a tuple like [string] (in which case this evaluates to
// true).
// eslint-disable-next-line @typescript-eslint/no-unused-vars
type IsTuple<T> = T extends [] ? true : T extends [infer First, ...infer Remain] ? IsTuple<Remain> : false;

type CallProperties<T> = T extends any[] ? IndexProperties<T> : keyof T;
type IterProperties<T> = T extends any[] ? IndexProperties<T> : ArrayProperties<T>;

type CallCallback<T, U> = (path: AstPath<T>, index: number, value: any) => U;
type EachCallback<T> = (path: AstPath<ArrayElement<T>>, index: number, value: any) => void;
type MapCallback<T, U> = (path: AstPath<ArrayElement<T>>, index: number, value: any) => U;

// https://github.com/prettier/prettier/blob/main/src/common/ast-path.js
export class AstPath<T = any> {
    constructor(value: T);
    stack: T[];
    callParent<U>(callback: (path: this) => U, count?: number): U;
    getName(): PropertyKey | null;
    getValue(): T;
    getNode(count?: number): T | null;
    getParentNode(count?: number): T | null;
    match(...predicates: Array<(node: 